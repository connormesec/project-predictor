[{"/Users/connormesec/projects/project-predictor/src/FileReader.js":"1","/Users/connormesec/projects/project-predictor/src/Chart.js":"2","/Users/connormesec/projects/project-predictor/src/index.js":"3","/Users/connormesec/projects/project-predictor/src/reportWebVitals.js":"4","/Users/connormesec/projects/project-predictor/src/App.js":"5","/Users/connormesec/projects/project-predictor/src/Dashboard.js":"6","/Users/connormesec/projects/project-predictor/src/monteCarlo.js":"7","/Users/connormesec/projects/project-predictor/src/CumulativeFlowDiagram.js":"8","/Users/connormesec/projects/project-predictor/src/MonteCarloFrequencyDiagram.js":"9","/Users/connormesec/projects/project-predictor/src/MonteCarloConfidenceValues.js":"10","/Users/connormesec/projects/project-predictor/src/LeadTimeFrequencyDiagram.js":"11","/Users/connormesec/projects/project-predictor/src/LeadTimeConfidenceValues.js":"12","/Users/connormesec/projects/project-predictor/src/LeadTimeRandomFrequencyDiagram.js":"13","/Users/connormesec/projects/project-predictor/src/WorkAddedConfidenceValues.js":"14"},{"size":6529,"mtime":1608677143973,"results":"15","hashOfConfig":"16"},{"size":34807,"mtime":1608569050368,"results":"17","hashOfConfig":"16"},{"size":458,"mtime":1608688922162,"results":"18","hashOfConfig":"16"},{"size":362,"mtime":1606414738432,"results":"19","hashOfConfig":"16"},{"size":211,"mtime":1608677790381,"results":"20","hashOfConfig":"16"},{"size":12706,"mtime":1609197305923,"results":"21","hashOfConfig":"16"},{"size":22941,"mtime":1609197545652,"results":"22","hashOfConfig":"16"},{"size":2637,"mtime":1609114999377,"results":"23","hashOfConfig":"16"},{"size":561,"mtime":1608758556765,"results":"24","hashOfConfig":"16"},{"size":1136,"mtime":1609116691280,"results":"25","hashOfConfig":"16"},{"size":500,"mtime":1608770163313,"results":"26","hashOfConfig":"16"},{"size":967,"mtime":1608770837617,"results":"27","hashOfConfig":"16"},{"size":510,"mtime":1608772180405,"results":"28","hashOfConfig":"16"},{"size":933,"mtime":1608794392438,"results":"29","hashOfConfig":"16"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"el2xh6",{"filePath":"32","messages":"33","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"38","messages":"39","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"40","messages":"41","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"42","messages":"43","errorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"44"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"54","messages":"55","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},"/Users/connormesec/projects/project-predictor/src/FileReader.js",["60","61","62"],"/Users/connormesec/projects/project-predictor/src/Chart.js",["63","64","65","66","67"],"/Users/connormesec/projects/project-predictor/src/index.js",[],"/Users/connormesec/projects/project-predictor/src/reportWebVitals.js",[],"/Users/connormesec/projects/project-predictor/src/App.js",["68"],"/Users/connormesec/projects/project-predictor/src/Dashboard.js",["69","70","71"],"/Users/connormesec/projects/project-predictor/src/monteCarlo.js",["72","73","74","75","76","77","78","79","80","81"],"import skewnorm from 'skew-normal-random';\nimport random from 'random';\n\nvar createdDate = 'Created';\nlet leadTimeMaxValue;\n\nfunction dateChange(data) {\n    let data3 = data.map(datastring => {\n        datastring['Lead Time'] = calcBusinessDays(new Date(datastring['In Progress']), new Date(datastring['Merged']));\n        datastring['In Progress'] = new Date(datastring['In Progress']);\n        datastring[createdDate] = new Date(datastring[createdDate]);\n        datastring['Merged'] = new Date(datastring['Merged']);\n        datastring['Closed'] = new Date(datastring['Closed']);\n        return datastring;\n    })\n    return data3;\n}\n\nfunction removeNotWorkedTickets(data) {\n    let newArr = [];\n    for (var i = 0; i < data.length; i++) {\n        if (!isValidDate(data[i].Closed) || (isValidDate(data[i].Closed) && isValidDate(data[i].Merged))) {\n            newArr.push(data[i]);\n        }\n    }\n    return newArr;\n}\n\nfunction calcBusinessDays(dDate1, dDate2) {         // input given as Date objects\n\n    var iWeeks, iDateDiff, iAdjust = 0;\n\n    if (dDate2 < dDate1) return -1;                 // error code if dates transposed\n\n    var iWeekday1 = dDate1.getDay();                // day of week\n    var iWeekday2 = dDate2.getDay();\n\n    iWeekday1 = (iWeekday1 == 0) ? 7 : iWeekday1;   // change Sunday from 0 to 7\n    iWeekday2 = (iWeekday2 == 0) ? 7 : iWeekday2;\n\n    if ((iWeekday1 > 5) && (iWeekday2 > 5)) iAdjust = 1;  // adjustment if both days on weekend\n\n    iWeekday1 = (iWeekday1 > 5) ? 5 : iWeekday1;    // only count weekdays\n    iWeekday2 = (iWeekday2 > 5) ? 5 : iWeekday2;\n\n    // calculate differnece in weeks (1000mS * 60sec * 60min * 24hrs * 7 days = 604800000)\n    iWeeks = Math.floor((dDate2.getTime() - dDate1.getTime()) / 604800000)\n\n    if (iWeekday1 <= iWeekday2) {\n        iDateDiff = (iWeeks * 5) + (iWeekday2 - iWeekday1)\n    } else {\n        iDateDiff = ((iWeeks + 1) * 5) - (iWeekday1 - iWeekday2)\n    }\n\n    iDateDiff -= iAdjust                            // take into account both days on weekend\n\n    return (iDateDiff + 1);                         // add 1 because dates are inclusive\n\n}\n\nfunction findEarliestDate(dateArray, startDate) {\n    var minIdx = 0, maxIdx = 0;\n    for (var i = 0; i < dateArray.length; i++) {\n        if (isValidDate(dateArray[i]['In Progress']) && isValidDate(dateArray[minIdx]['In Progress'])) {\n            if (dateArray[i]['In Progress'] > dateArray[maxIdx]['In Progress']) maxIdx = i;\n            if (dateArray[i]['In Progress'] < dateArray[minIdx]['In Progress']) minIdx = i;\n        }\n        if (isValidDate(dateArray[i]['In Progress']) && isValidDate(dateArray[minIdx]['In Progress']) == false) minIdx = i;\n    }\n    if (!startDate) {\n        return new Date(dateArray[minIdx]['In Progress']);\n    } else {\n        return startDate;\n    }\n}\n\nfunction isValidDate(date) {\n    return date && Object.prototype.toString.call(date) === \"[object Date]\" && !isNaN(date);\n}\n\nfunction createDateArray(array, today, minimum, backlogOverride) {\n    var graphXAxisNum = Math.floor(today.getTime() - minimum.getTime()) / 86400000;\n    var xaxis = [];\n    for (var j = 0; j < graphXAxisNum; j++) {\n        let day = {\n            \"Day\": addDays(minimum, j),\n            \"Backlog\": getBacklogAndWorkDone(addDays(minimum, j), array, createdDate),\n            \"Work_Done\": getBacklogAndWorkDone(addDays(minimum, j), array, 'Merged'),\n            \"Work_Added\": getBacklogAndWorkDone(addDays(minimum, j), array, createdDate) - getBacklogAndWorkDone(addDays(minimum, j - 1), array, createdDate),\n        }\n        xaxis[j] = day;\n    }\n    if (backlogOverride) {\n        xaxis[Math.floor(graphXAxisNum)].Backlog = backlogOverride;\n    }\n    return xaxis;\n}\n\nfunction addDays(date, days) {\n    var result = new Date(date);\n    result.setDate(result.getDate() + days);\n    return result;\n}\n\nfunction getBacklogAndWorkDone(date, array, key) {\n    let count = 0;\n    for (var j = 0; j < array.length; j++) {\n        if (isValidDate(date) && isValidDate(array[j][key])) {\n            if (date.getTime() > array[j][key].getTime()) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\n\nfunction computeMeanSdAndItervalRangeMinMax(list) {\n    const sum = list.reduce((a, b) => a + b, 0);\n    const mean = list.reduce((a, b) => a + b) / list.length;\n    const sumMinusMean = list.reduce((a, b) => a + (b - mean) * (b - mean), 0);\n    const logNorm = list.map(x => Math.log(x))\n\n    return {\n        mean: mean,\n        sd: Math.sqrt(sumMinusMean / (list.length - 1)),\n        mode: median(mode(list)),\n        median: median(list),\n        range: [Math.min(...list), Math.max(...list)],\n        best_case: mean - 2 * (Math.sqrt(sumMinusMean / (list.length - 1))),\n        worst_case: mean + 2 * (Math.sqrt(sumMinusMean / (list.length - 1))),\n        logNormal: logNorm\n    };\n}\n\nfunction mode(numbers) {\n    // as result can be bimodal or multi-modal,\n    // the returned result is provided as an array\n    // mode of [3, 5, 4, 4, 1, 1, 2, 3] = [1, 3, 4]\n    var modes = [], count = [], i, number, maxIndex = 0, result = [];\n    for (let i = 0; i < numbers.length; i++) {\n        let rand_num = numbers[i];\n        let rounded = round_to_precision(rand_num, 1)\n        result.push(rounded);\n    }\n\n    for (i = 0; i < result.length; i += 1) {\n        number = result[i];\n        count[number] = (count[number] || 0) + 1;\n        if (count[number] > maxIndex) {\n            maxIndex = count[number];\n        }\n    }\n\n    for (i in count)\n        if (count.hasOwnProperty(i)) {\n            if (count[i] === maxIndex) {\n                modes.push(Number(i));\n            }\n        }\n\n    return modes;\n}\n\nfunction median(numbers) {\n    // median of [3, 5, 4, 4, 1, 1, 2, 3] = 3\n    var median = 0, numsLen = numbers.length;\n    numbers.sort((a, b) => a - b);\n\n    if (\n        numsLen % 2 === 0 // is even\n    ) {\n        // average of two middle numbers\n        median = (numbers[numsLen / 2 - 1] + numbers[numsLen / 2]) / 2;\n    } else { // is odd\n        // middle number only\n        median = numbers[(numsLen - 1) / 2];\n    }\n    return median;\n}\n\n//get the last ll tickets worked to completion\n//TODO: Make it so last 11 tickets respect start date\nfunction lastElevenTickets(array, today, startDate) {\n    var temp = array.slice().sort((a, b) => b['Merged'] - a['Merged']);\n\n    let l = 0;\n    let testarr = [];\n\n    for (var k = 0; k < temp.length; k++) {\n        if (l >= 11) break;\n        if (isValidDate(temp[k]['Merged']) && temp[k]['Merged'] < today && temp[k]['Lead Time'] < leadTimeMaxValue && temp[k]['Merged'] > startDate) {\n            testarr.push(temp[k]);\n            l = l + 1;\n        }\n    }\n    //mostRecentElevenTicketsArray = testarr\n    return testarr;\n}\n\n\nfunction workInParrallel(array, today, workInParrallelOverride) {\n    if (workInParrallelOverride) {\n        return workInParrallelOverride;\n    } else {\n    let dateRange = [];\n    const lastDay = {\n        date: today,\n        in_progress: false,\n        merged: false,\n        last_day: true\n    };\n    for (var i = 0; i < array.length; i++) {\n        if (isValidDate(array[i]['In Progress']) && isValidDate(array[i]['Merged'])) {\n            const toadd = [{\n                date: array[i]['In Progress'],\n                in_progress: true,\n                merged: false,\n                last_day: false\n            }, {\n                date: array[i]['Merged'],\n                in_progress: false,\n                merged: true,\n                last_day: false\n            }];\n            dateRange = dateRange.concat(toadd);\n        }\n        if (isValidDate(array[i]['In Progress']) && !isValidDate(array[i]['Merged'])) {\n            dateRange = dateRange.concat({\n                date: array[i]['In Progress'],\n                in_progress: true,\n                merged: false,\n                last_day: false\n            });\n        }\n        if (array[i]['In Prgress'] >= today) break;\n    }\n    dateRange = dateRange.concat(lastDay);\n    //[0] earliest date -> [n] last date\n    var filteredDateRange = dateRange.slice().sort((a, b) => a.date - b.date);\n    if (!filteredDateRange[0].in_progress) console.error(\"something is wrong with this csv, the first item has a merged date before the in progress date\");\n    let multiplyer = 1;\n    let sum = 0;\n    for (var j = 0; j < filteredDateRange.length - 1; j++) {\n\n        sum = sum + ((filteredDateRange[j + 1].date.getTime() - filteredDateRange[j].date.getTime()) * multiplyer);\n        if (filteredDateRange[j + 1].in_progress) {\n            multiplyer++;\n        }\n        if (filteredDateRange[j + 1].merged) {\n            multiplyer--;\n        }\n        if (filteredDateRange[j + 1].last_day) {\n            break;\n        }\n    }\n    let total = today.getTime() - filteredDateRange[0].date.getTime();\n    let workInParrallelValue = sum / total;\n    \n    return workInParrallelValue;\n    }\n}\n\n\nfunction randNumFromDistribution(rangeObject, distributionType) {\n\n    let n = 10000;\n    let temparray = [];\n    let logNorm = computeMeanSdAndItervalRangeMinMax(rangeObject.logNormal)\n\n    const randn_bm = () => {\n        var u = 0, v = 0;\n        while (u === 0) u = Math.random(); //Converting [0,1) to (0,1)\n        while (v === 0) v = Math.random();\n        const R = Math.sqrt(-2.0 * Math.log(u));\n        const Θ = 2.0 * Math.PI * v;\n        const test = [R * Math.cos(Θ), R * Math.sin(Θ)];\n\n        const mean = rangeObject.mean;\n        const ω = rangeObject.sd;\n        //Pearson's first skewness coefficient (mode skewness)\n        const α = (rangeObject.mean - rangeObject.mode) / ω;\n        const 𝛿 = α / Math.sqrt(1 + α * α);\n        const ξ = rangeObject.mean - ω * 𝛿 * Math.sqrt(2 / Math.PI);\n        const med = rangeObject.median;\n\n        function randomNormal(ξ, ω, median) {\n            let num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);\n            num = num * ω + median;\n            if ((num - median) / ω > 3) return randn_bm(); // remove outliers more than 3 standard deviations away from median\n            return num;\n        }\n\n        // function randomSkewNormal(test, ξ, ω, α = 7) {\n        //     const [u0, v] = test;\n        //     if (α === 0) {\n        //         return ξ + ω * u0;\n        //     }\n        //     const 𝛿 = α / Math.sqrt(1 + α * α);\n        //     const u1 = 𝛿 * u0 + Math.sqrt(1 - 𝛿 * 𝛿) * v;\n        //     //const z = u0 >= 0 ? u1 : -u1;\n        //     const z = u1;\n        //     //origin was ξ + ω * z\n        //     let num = ξ + ω * z;\n        //     //if (num < 0) num = randn_bm();\n        //     return num;\n        // }\n\n        function randomSkewNormal(alpha, location, scale) {\n            let num = skewnorm.rSkewNorm(alpha, location, scale);\n            return num;\n        }\n\n        function randomLogNormal() {\n            let num = random.logNormal(logNorm.mean, logNorm.sd)();\n            if (num > leadTimeMaxValue) return randn_bm();\n            return num;\n        }\n\n\n        if (distributionType == \"Skew-Normal\") {\n            return randomSkewNormal(α, ξ, ω);\n        } else if (distributionType == \"Normal\") {\n            return randomNormal(mean, ω, med);\n        } else if (distributionType == \"Log-Normal\") {\n            return randomLogNormal();\n        } else {\n            return null;\n        }\n\n    }\n\n\n    // Create n samples between min and max\n    for (let i = 0; i < n; i++) {\n        let rand_num = randn_bm();\n        temparray.push(rand_num);\n        }\n    return temparray;\n}\n\nfunction monteCarlo(dates, randomNumsLeadTime, randomNumsWorkAdded, today, formattedData, startDate, workInParrallelOverride) {\n    let workLeft = dates[dates.length - 1].Backlog - dates[dates.length - 1].Work_Done;\n    let adjustedWorkLeft = workLeft / workInParrallel(lastElevenTickets(formattedData, today, startDate), today, workInParrallelOverride);\n    let sum = randomNumsLeadTime[Math.floor(Math.random() * randomNumsLeadTime.length)] * adjustedWorkLeft;\n    if (sum < 0) sum = 0;\n    \n    return sum //* (1 + randomNumsWorkAdded[Math.floor(Math.random() * randomNumsWorkAdded.length)]);\n}\n\nfunction runMonteCarlo(n, dates, randomNumsLeadTime, randomNumsWorkAdded, today, formattedData, startDate, workInParrallelOverride) {\n    let runArray = [];\n    for (let i = 0; i < n; i++) {\n        runArray.push(monteCarlo(dates, randomNumsLeadTime, randomNumsWorkAdded, today, formattedData, startDate, workInParrallelOverride));\n    }\n    let monteCarloResults = {\n        daysToCompletionArray: runArray,\n        finalDistributionValuies: computeMeanSdAndItervalRangeMinMax(runArray),\n        workInParrallelValue: workInParrallel(lastElevenTickets(formattedData, today, startDate), today, workInParrallelOverride),\n        randomWorkAdded: computeMeanSdAndItervalRangeMinMax(randomNumsWorkAdded),\n        confidence: getConfidence(runArray),\n        bestAndWorstCaseForPlotObject: bestAndWorstCaseForPlot(dates, computeMeanSdAndItervalRangeMinMax(runArray), computeMeanSdAndItervalRangeMinMax(randomNumsWorkAdded), getConfidence(runArray))\n\n    };\n    console.log(monteCarloResults);\n    return monteCarloResults;\n}\n\nconst round_to_precision = (x, precision) => {\n    var y = +x + (precision === undefined ? 0.5 : precision / 2);\n    return y - (y % (precision === undefined ? 1 : +precision));\n}\n\nfunction getConfidence(rawDataArray) {\n    let result = [];\n\n    for (let j = 0; j < Math.max(...rawDataArray); j++) {\n        result[j] = 0;\n    }\n\n    for (let i = 0; i < rawDataArray.length; i++) {\n        let rand_num = rawDataArray[i];\n        let rounded = round_to_precision(rand_num, 1)\n        result[rounded] += 1;\n    }\n\n    let hc_data = [];\n    for (const [key, val] of Object.entries(result)) {\n        hc_data.push({ \"x\": parseFloat(key), \"y\": val / rawDataArray.length });\n    }\n\n    // Sort\n    hc_data = hc_data.sort(function (a, b) {\n        if (a.x < b.x) return -1;\n        if (a.x > b.x) return 1;\n        return 0;\n    });\n\n    //TODO: use hc_data as a way to create a custom frequency distribution\n    let sum = 0;\n    let confidence = [\n        { percent: 25, value: undefined },\n        { percent: 50, value: undefined },\n        { percent: 75, value: undefined },\n        { percent: 90, value: undefined },\n        { percent: 95, value: undefined },\n        { percent: 99, value: undefined }\n    ];\n    for (let k = 0; k < hc_data.length; k++) {\n        sum = sum + hc_data[k].y * 100;\n        for (let l = 0; l < confidence.length; l++) {\n            if (sum < confidence[l].percent) {\n                confidence[l].value = hc_data[k].x + 1;\n            }\n        }\n    }\n\n    return confidence;\n}\n\nfunction bestAndWorstCaseForPlot(historicalData, finalDistributionValuies, randomWorkAdded, confidence) {\n\n    let lastDay = historicalData[historicalData.length - 1].Day.getTime() / 86400000;\n    let lastDayBacklogTotal = historicalData[historicalData.length - 1].Backlog;\n    let lastDayDoneTotal = historicalData[historicalData.length - 1].Work_Done;\n    let worstCaseDays = confidence[5].value;\n    let ninetyFivePercent = confidence[4].value;\n    let ninetyPercent = confidence[3].value;\n    let seventyFivePercent = confidence[2].value;\n    let fiftyPercent = confidence[1].value;\n    let bestCaseDays = confidence[0].value;\n    let averageWorkAdded = randomWorkAdded.median;\n    let resultArray = [];\n    for (let i = 0; i < worstCaseDays; i++) {\n        const date = new Date((i + lastDay) * 86400000), \n        bckLgInc = averageWorkAdded * i + lastDayBacklogTotal, \n        doneWC = (i * (((averageWorkAdded * worstCaseDays) + lastDayBacklogTotal) - lastDayDoneTotal) / worstCaseDays) + lastDayDoneTotal, \n        CF95 = (i * (((averageWorkAdded * ninetyFivePercent) + lastDayBacklogTotal) - lastDayDoneTotal) / ninetyFivePercent) + lastDayDoneTotal, \n        CF90 = (i * (((averageWorkAdded * ninetyPercent) + lastDayBacklogTotal) - lastDayDoneTotal) / ninetyPercent) + lastDayDoneTotal, \n        CF75 = (i * (((averageWorkAdded * seventyFivePercent) + lastDayBacklogTotal) - lastDayDoneTotal) / seventyFivePercent) + lastDayDoneTotal, \n        CF50 = (i * (((averageWorkAdded * fiftyPercent) + lastDayBacklogTotal) - lastDayDoneTotal) / fiftyPercent) + lastDayDoneTotal, \n        CF25 = (i * (((averageWorkAdded * bestCaseDays) + lastDayBacklogTotal) - lastDayDoneTotal) / bestCaseDays) + lastDayDoneTotal;\n        if (CF95 > lastDayBacklogTotal) {\n            resultArray.push(\n                {\n                    day: date,\n                    backlogIncrease: bckLgInc,\n                    doneWorstCase: doneWC,\n                }\n            );\n        } else if (CF90 > lastDayBacklogTotal) {\n            resultArray.push(\n                {\n                    day: date,\n                    backlogIncrease: bckLgInc,\n                    doneWorstCase: doneWC,\n                    confidence95: CF95,\n                }\n            );\n        } else if (CF75 > lastDayBacklogTotal) {\n            resultArray.push(\n                {\n                    day: date,\n                    backlogIncrease: bckLgInc,\n                    doneWorstCase: doneWC,\n                    confidence95: CF95,\n                    confidence90: CF90\n                }\n            );\n        }else if (CF50 > lastDayBacklogTotal) {\n            resultArray.push(\n                {\n                    day: date,\n                    backlogIncrease: bckLgInc,\n                    doneWorstCase: doneWC,\n                    confidence95: CF95,\n                    confidence90: CF90,\n                    confidence75: CF75\n                }\n            );\n        }else if (CF25 > lastDayBacklogTotal) {\n            resultArray.push(\n                {\n                    day: date,\n                    backlogIncrease: bckLgInc,\n                    doneWorstCase: doneWC,\n                    confidence95: CF95,\n                    confidence90: CF90,\n                    confidence75: CF75,\n                    confidence50: CF50\n                }\n            );\n        } else {\n            resultArray.push(\n                {\n                    day: date,\n                    backlogIncrease: bckLgInc,\n                    doneWorstCase: doneWC,\n                    confidence95: CF95,\n                    confidence90: CF90,\n                    confidence75: CF75,\n                    confidence50: CF50,\n                    confidence25: CF25\n                }\n            )\n        }\n    }\n    return resultArray;\n}\n\n\nfunction formatDate(date) {\n    if (!isValidDate(date)){\n        return null\n    } else {\n    var d = new Date(date),\n        month = '' + (d.getMonth() + 1),\n        day = '' + d.getDate(),\n        year = d.getFullYear();\n\n    if (month.length < 2) \n        month = '0' + month;\n    if (day.length < 2) \n        day = '0' + day;\n\n    return [year, month, day].join('-');\n    }\n}\n\nfunction test(startDate, today, formattedData, distType) {\n    let randomArr = randNumFromDistribution(computeMeanSdAndItervalRangeMinMax(lastElevenTickets(formattedData, today).map(o => o['Lead Time'])), distType);\n    return runMonteCarlo(10000, createDateArray(formattedData, today, findEarliestDate(formattedData, startDate)), randomArr, createDateArray(formattedData, today, findEarliestDate(formattedData, startDate)).map(o => o.Work_Added), today, formattedData)\n}\n\n\nexport function monteCarloFunction(props) {\n    console.log(props);\n    let today = new Date(props.data.simulationDate);\n    const distType = props.data.distribution;\n    let startDate = props.data.startDate == null ? false : new Date(props.data.startDate);\n    //set lead time max value\n    (props.data.leadTimeMaxValueOverride) ? leadTimeMaxValue = props.data.leadTimeMaxValueOverride : leadTimeMaxValue = 10000;\n    console.log(leadTimeMaxValue)\n    const formattedData = removeNotWorkedTickets(dateChange(props.data.data));\n    const leadTimeLastEleven = (props.data.leadTimeOverride) ? props.data.leadTimeOverride.split(',').map(x => x*1) : lastElevenTickets(formattedData, today, findEarliestDate(formattedData, startDate)).map(o => o['Lead Time']);\n    let forplot = createDateArray(formattedData, today, findEarliestDate(formattedData, startDate), props.data.backlogOverride);\n    console.log(forplot)\n    const lastElevenData = computeMeanSdAndItervalRangeMinMax(leadTimeLastEleven);\n    const randLastElevenData = computeMeanSdAndItervalRangeMinMax(randNumFromDistribution(lastElevenData, distType));\n    const workAdded = computeMeanSdAndItervalRangeMinMax(forplot.map(o => o.Work_Added));\n    const randWorkadded = computeMeanSdAndItervalRangeMinMax(randNumFromDistribution(workAdded));\n    let myBoyMonte = runMonteCarlo(10000, forplot, randNumFromDistribution(computeMeanSdAndItervalRangeMinMax(leadTimeLastEleven), distType), forplot.map(o => o.Work_Added), today, formattedData,findEarliestDate(formattedData, startDate), props.data.workInParrallelOverride);\n    let plotdata = []\n    for (let i = 0; i < forplot.map(o => o.Day).concat(myBoyMonte.bestAndWorstCaseForPlotObject.map(o => o.day).slice(1)).length; i++) {\n        plotdata.push({\n        days : forplot.map(o => o.Day).concat(myBoyMonte.bestAndWorstCaseForPlotObject.map(o => o.day).slice(1))[i],\n        backlog : forplot.map(o => o.Backlog)[i],\n        workDone : forplot.map(o => o.Work_Done)[i],\n        workIncrease : new Array(forplot.map(o => o.Day).length-1).fill(undefined).concat(myBoyMonte.bestAndWorstCaseForPlotObject.map(o => o.backlogIncrease))[i],\n        worstCase : new Array(forplot.map(o => o.Day).length-1).fill(undefined).concat(myBoyMonte.bestAndWorstCaseForPlotObject.map(o => o.doneWorstCase))[i],        \n        confidence25 : new Array(forplot.map(o => o.Day).length-1).fill(undefined).concat(myBoyMonte.bestAndWorstCaseForPlotObject.map(o => o.confidence25))[i],\n        confidence50 : new Array(forplot.map(o => o.Day).length-1).fill(undefined).concat(myBoyMonte.bestAndWorstCaseForPlotObject.map(o => o.confidence50))[i],\n        confidence75 : new Array(forplot.map(o => o.Day).length-1).fill(undefined).concat(myBoyMonte.bestAndWorstCaseForPlotObject.map(o => o.confidence75))[i],\n        confidence90 : new Array(forplot.map(o => o.Day).length-1).fill(undefined).concat(myBoyMonte.bestAndWorstCaseForPlotObject.map(o => o.confidence90))[i],\n        confidence95 : new Array(forplot.map(o => o.Day).length-1).fill(undefined).concat(myBoyMonte.bestAndWorstCaseForPlotObject.map(o => o.confidence95))[i]\n    });\n    }\n    return {\n        monte : myBoyMonte,\n        plotData : plotdata,\n        leadtime : {\n            leadTimeLastEleven : leadTimeLastEleven,\n            lastElevenData : lastElevenData,\n            randLastElevenData : randLastElevenData,\n            randLeadTimeData : randNumFromDistribution(lastElevenData, distType)\n        },\n        workAdded : {\n            workAdded : workAdded,\n            randWorkAdded : randWorkadded\n        }\n    }\n}","/Users/connormesec/projects/project-predictor/src/CumulativeFlowDiagram.js",[],["82","83"],"/Users/connormesec/projects/project-predictor/src/MonteCarloFrequencyDiagram.js",[],"/Users/connormesec/projects/project-predictor/src/MonteCarloConfidenceValues.js",[],"/Users/connormesec/projects/project-predictor/src/LeadTimeFrequencyDiagram.js",[],"/Users/connormesec/projects/project-predictor/src/LeadTimeConfidenceValues.js",["84"],"/Users/connormesec/projects/project-predictor/src/LeadTimeRandomFrequencyDiagram.js",[],"/Users/connormesec/projects/project-predictor/src/WorkAddedConfidenceValues.js",[],{"ruleId":"85","severity":1,"message":"86","line":27,"column":28,"nodeType":"87","messageId":"88","endLine":27,"endColumn":47},{"ruleId":"85","severity":1,"message":"89","line":161,"column":10,"nodeType":"87","messageId":"88","endLine":161,"endColumn":29},{"ruleId":"85","severity":1,"message":"90","line":173,"column":10,"nodeType":"87","messageId":"88","endLine":173,"endColumn":22},{"ruleId":"91","severity":1,"message":"92","line":39,"column":28,"nodeType":"93","messageId":"94","endLine":39,"endColumn":30},{"ruleId":"91","severity":1,"message":"92","line":40,"column":28,"nodeType":"93","messageId":"94","endLine":40,"endColumn":30},{"ruleId":"91","severity":1,"message":"92","line":69,"column":103,"nodeType":"93","messageId":"94","endLine":69,"endColumn":105},{"ruleId":"85","severity":1,"message":"95","line":117,"column":11,"nodeType":"87","messageId":"88","endLine":117,"endColumn":14},{"ruleId":"85","severity":1,"message":"96","line":270,"column":15,"nodeType":"87","messageId":"88","endLine":270,"endColumn":19},{"ruleId":"85","severity":1,"message":"97","line":2,"column":8,"nodeType":"87","messageId":"88","endLine":2,"endColumn":18},{"ruleId":"85","severity":1,"message":"98","line":2,"column":10,"nodeType":"87","messageId":"88","endLine":2,"endColumn":23},{"ruleId":"85","severity":1,"message":"99","line":149,"column":9,"nodeType":"87","messageId":"88","endLine":149,"endColumn":25},{"ruleId":"85","severity":1,"message":"100","line":157,"column":10,"nodeType":"87","messageId":"88","endLine":157,"endColumn":14},{"ruleId":"91","severity":1,"message":"92","line":38,"column":28,"nodeType":"93","messageId":"94","endLine":38,"endColumn":30},{"ruleId":"91","severity":1,"message":"92","line":39,"column":28,"nodeType":"93","messageId":"94","endLine":39,"endColumn":30},{"ruleId":"91","severity":1,"message":"92","line":68,"column":103,"nodeType":"93","messageId":"94","endLine":68,"endColumn":105},{"ruleId":"85","severity":1,"message":"95","line":119,"column":11,"nodeType":"87","messageId":"88","endLine":119,"endColumn":14},{"ruleId":"85","severity":1,"message":"96","line":277,"column":15,"nodeType":"87","messageId":"88","endLine":277,"endColumn":19},{"ruleId":"91","severity":1,"message":"92","line":321,"column":30,"nodeType":"93","messageId":"94","endLine":321,"endColumn":32},{"ruleId":"91","severity":1,"message":"92","line":323,"column":37,"nodeType":"93","messageId":"94","endLine":323,"endColumn":39},{"ruleId":"91","severity":1,"message":"92","line":325,"column":37,"nodeType":"93","messageId":"94","endLine":325,"endColumn":39},{"ruleId":"85","severity":1,"message":"101","line":512,"column":10,"nodeType":"87","messageId":"88","endLine":512,"endColumn":20},{"ruleId":"85","severity":1,"message":"102","line":530,"column":10,"nodeType":"87","messageId":"88","endLine":530,"endColumn":14},{"ruleId":"103","replacedBy":"104"},{"ruleId":"105","replacedBy":"106"},{"ruleId":"85","severity":1,"message":"107","line":2,"column":7,"nodeType":"87","messageId":"88","endLine":2,"endColumn":11},"no-unused-vars","'setMonteCarloResult' is assigned a value but never used.","Identifier","unusedVar","'DatePickerStartDate' is defined but never used.","'exportToJson' is defined but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'sum' is assigned a value but never used.","'test' is assigned a value but never used.","'FileReader' is defined but never used.","'ErrorBoundary' is defined but never used.","'fixedHeightPaper' is assigned a value but never used.","'data' is assigned a value but never used.","'formatDate' is defined but never used.","'test' is defined but never used.","no-native-reassign",["108"],"no-negated-in-lhs",["109"],"'mean' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]