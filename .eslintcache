[{"/Users/connormesec/projects/project-predictor/src/Chart.js":"1"},{"size":14625,"mtime":1606797647779,"results":"2","hashOfConfig":"3"},{"filePath":"4","messages":"5","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"6"},"b8e2tx","/Users/connormesec/projects/project-predictor/src/Chart.js",["7","8","9","10","11","12"],"import React from 'react';\nimport Plot from 'react-plotly.js';\n\n\nvar minimum = new Date();\nvar today = new Date('2020-10-12');\nvar forplot = [];\nvar mostRecentElevenTicketsArray = [];\nlet randomData = [];\n\nfunction formatData(data) {\n    dateChange(data);\n    lastElevenTickets(data, today);\n    findEarliestAndLatestDate(data);\n    createDateArray(data);\n    //lastElevenLeadTime(data, today);\n    workInParrallel(mostRecentElevenTicketsArray);\n    return data;\n}\n\n\nfunction dateChange(data) {\n    let data3 = data.map(datastring => {\n        datastring['Lead Time'] = calcBusinessDays(new Date(datastring['In Progress']), new Date(datastring['Merged']));\n        datastring['In Progress'] = new Date(datastring['In Progress']);\n        datastring['Created Date'] = new Date(datastring['Created Date']);\n        datastring['Merged'] = new Date(datastring['Merged']);\n        return datastring;\n    })\n    return data3;\n}\n\nfunction calcBusinessDays(dDate1, dDate2) {         // input given as Date objects\n\n    var iWeeks, iDateDiff, iAdjust = 0;\n\n    if (dDate2 < dDate1) return -1;                 // error code if dates transposed\n\n    var iWeekday1 = dDate1.getDay();                // day of week\n    var iWeekday2 = dDate2.getDay();\n\n    iWeekday1 = (iWeekday1 == 0) ? 7 : iWeekday1;   // change Sunday from 0 to 7\n    iWeekday2 = (iWeekday2 == 0) ? 7 : iWeekday2;\n\n    if ((iWeekday1 > 5) && (iWeekday2 > 5)) iAdjust = 1;  // adjustment if both days on weekend\n\n    iWeekday1 = (iWeekday1 > 5) ? 5 : iWeekday1;    // only count weekdays\n    iWeekday2 = (iWeekday2 > 5) ? 5 : iWeekday2;\n\n    // calculate differnece in weeks (1000mS * 60sec * 60min * 24hrs * 7 days = 604800000)\n    iWeeks = Math.floor((dDate2.getTime() - dDate1.getTime()) / 604800000)\n\n    if (iWeekday1 <= iWeekday2) {\n        iDateDiff = (iWeeks * 5) + (iWeekday2 - iWeekday1)\n    } else {\n        iDateDiff = ((iWeeks + 1) * 5) - (iWeekday1 - iWeekday2)\n    }\n\n    iDateDiff -= iAdjust                            // take into account both days on weekend\n\n    return (iDateDiff + 1);                         // add 1 because dates are inclusive\n\n}\n\nfunction findEarliestAndLatestDate(dateArray) {\n    var minIdx = 0, maxIdx = 0;\n    for (var i = 0; i < dateArray.length; i++) {\n        if (isValidDate(dateArray[i]['In Progress']) && isValidDate(dateArray[minIdx]['In Progress'])) {\n            if (dateArray[i]['In Progress'] > dateArray[maxIdx]['In Progress']) maxIdx = i;\n            if (dateArray[i]['In Progress'] < dateArray[minIdx]['In Progress']) minIdx = i;\n        }\n        if (isValidDate(dateArray[i]['In Progress']) && isValidDate(dateArray[minIdx]['In Progress']) == false) minIdx = i;\n    }\n    minimum = new Date(dateArray[minIdx]['In Progress']);\n    console.log(minimum);\n    //maximum = new Date(dateArray[maxIdx]['In Progress']);\n    return dateArray;\n}\n\nfunction isValidDate(date) {\n    return date && Object.prototype.toString.call(date) === \"[object Date]\" && !isNaN(date);\n}\n\nfunction createDateArray(array) {\n    var graphXAxisNum = Math.floor(today.getTime() - minimum.getTime()) / 86400000;\n    console.log(graphXAxisNum);\n    var xaxis = [];\n    for (var j = 0; j < graphXAxisNum; j++) {\n        let day = {\n            \"Day\": addDays(minimum, j),\n            \"Backlog\": getBacklogAndWorkDone(addDays(minimum, j), array, 'Created Date'),\n            \"Work_Done\": getBacklogAndWorkDone(addDays(minimum, j), array, 'Merged'),\n            \"Work_Added\": getBacklogAndWorkDone(addDays(minimum, j), array, 'Created Date') - getBacklogAndWorkDone(addDays(minimum, j-1), array, 'Created Date'),\n        }\n        xaxis[j] = day;\n    }\n    forplot = xaxis;\n    console.log(xaxis);\n}\n\nfunction addDays(date, days) {\n    var result = new Date(date);\n    result.setDate(result.getDate() + days);\n    return result;\n}\n\nfunction getBacklogAndWorkDone(date, array, key) {\n    let count = 0;\n    for (var j = 0; j < array.length; j++) {\n        if (isValidDate(date) && isValidDate(array[j][key])) {\n            if (date.getTime() > array[j][key].getTime()) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nfunction lastElevenLeadTime(array, today) {\n    var leadTime = array.slice().sort((a, b) => b['Merged'] - a['Merged']);\n    let leadTimeEleven = [];\n    let j = 0;\n    let i = 0;\n    do {\n        if (leadTime[j]['Merged'] < today && isValidDate(leadTime[j]['Merged'])) {\n            leadTimeEleven.push(leadTime[j]['Lead Time']);\n            i = i + 1;\n            j = j + 1;\n        } else { j = j + 1; }\n    } while (i < 11 || i >= leadTime.length)\n    return leadTimeEleven;\n}\n\nfunction computeMeanSdAndItervalRangeMinMax(list) {\n    const sum = list.reduce((a, b) => a + b, 0);\n    const mean = sum / list.length;\n    const sumMinusMean = list.reduce((a, b) => a + (b - mean) * (b - mean), 0);\n\n    return {\n        mean: mean,\n        sd: Math.sqrt(sumMinusMean / (list.length - 1)),\n        mode: median(mode(list)),\n        median: median(list),\n        range: [Math.min(...list), Math.max(...list)]\n    };\n}\n\nfunction mode(numbers) {\n    // as result can be bimodal or multi-modal,\n    // the returned result is provided as an array\n    // mode of [3, 5, 4, 4, 1, 1, 2, 3] = [1, 3, 4]\n    var modes = [], count = [], i, number, maxIndex = 0;\n \n    for (i = 0; i < numbers.length; i += 1) {\n        number = numbers[i];\n        count[number] = (count[number] || 0) + 1;\n        if (count[number] > maxIndex) {\n            maxIndex = count[number];\n        }\n    }\n \n    for (i in count)\n        if (count.hasOwnProperty(i)) {\n            if (count[i] === maxIndex) {\n                modes.push(Number(i));\n            }\n        }\n \n    return modes;\n}\n\nfunction median(numbers) {\n    // median of [3, 5, 4, 4, 1, 1, 2, 3] = 3\n    var median = 0, numsLen = numbers.length;\n    numbers.sort();\n \n    if (\n        numsLen % 2 === 0 // is even\n    ) {\n        // average of two middle numbers\n        median = (numbers[numsLen / 2 - 1] + numbers[numsLen / 2]) / 2;\n    } else { // is odd\n        // middle number only\n        median = numbers[(numsLen - 1) / 2];\n    }\n \n    return median;\n}\n\n//get the last ll tickets worked to completion\nfunction lastElevenTickets(array, today) {\n    var temp = array.slice().sort((a, b) => b['Merged'] - a['Merged']);\n    let mostRecentElevenTickets = [];\n    let j = 0;\n    let i = 0;\n    do {\n        if (temp[j]['Merged'] < today && isValidDate(temp[j]['Merged'])) {\n            mostRecentElevenTickets.push(temp[j]);\n            i = i + 1;\n            j = j + 1;\n        } else { j = j + 1; }\n    } while (i < 11 || i >= temp.length)\n    mostRecentElevenTicketsArray = mostRecentElevenTickets;\n}\n\n\nfunction workInParrallel(array) {\n    let dateRange = [];\n    const lastDay = {date: new Date (today),\n    in_progress: false,\n    merged: false,\n    last_day: true};\n    for (var i = 0; i < array.length; i++) {\n        if(isValidDate(array[i]['In Progress']) && isValidDate(array[i]['Merged'])) {\n            const toadd = [{\n                date: array[i]['In Progress'],\n                in_progress: true,\n                merged: false,\n                last_day: false\n            },{\n                date: array[i]['Merged'],\n                in_progress: false,\n                merged: true,\n                last_day: false\n            }];\n            dateRange = dateRange.concat(toadd);\n        }\n        if(isValidDate(array[i]['In Progress']) && !isValidDate(array[i]['Merged'])) {\n            dateRange = dateRange.concat({\n                date: array[i]['In Progress'],\n                in_progress: true,\n                merged: false,\n                last_day: false\n            });\n        }\n        if(array[i]['In Prgress'] >= today) break;\n    }\n    dateRange = dateRange.concat(lastDay);\n    //[0] earliest date -> [n] last date\n    var filteredDateRange = dateRange.slice().sort((a, b) => a.date - b.date);\n    if (!filteredDateRange[0].in_progress) console.error(\"something is wrong with this csv, the first item has a merged date before the in progress date\");\n    let multiplyer = 1;\n    let sum = 0;\n    for (var j = 0; j < filteredDateRange.length - 1; j++) {\n        \n        sum = sum + ((filteredDateRange[j + 1].date.getTime() - filteredDateRange[j].date.getTime()) * multiplyer);\n        if (filteredDateRange[j + 1].in_progress) {\n            multiplyer++;\n        }\n        if (filteredDateRange[j + 1].merged) {\n            multiplyer--;\n        }\n        if (filteredDateRange[j + 1].last_day) {\n            break;\n        }\n    }\n    let total = today.getTime() - filteredDateRange[0].date.getTime();\n    let workInParrallelValue = sum/total;\n    \n    return workInParrallelValue;\n\n}\n\n\nfunction leadTimeAnalysis(rangeObject) {\n\nlet n = 10000;\nlet step = 1;\nlet max = rangeObject.range[1];\nlet min = rangeObject.range[0];\nlet skew = 0;\nlet temparray = [];\n\n\nconst randn_bm = (min, max, skew) => {\n    var u = 0, v = 0;\n    while(u === 0) u = Math.random(); //Converting [0,1) to (0,1)\n    while(v === 0) v = Math.random();\n    const R = Math.sqrt(-2.0 * Math.log(u));\n    const Θ = 2.0 * Math.PI * v;\n    const test = [R * Math.cos(Θ), R * Math.sin(Θ)];\n    const ξ = rangeObject.median;\n    const ω = rangeObject.sd;\n    const α = (( max - ξ )/ ω );\n    function randomSkewNormal(test, ξ, ω, α) {\n        const [u0, v] = test;\n        if (α === 0) {\n            return ξ + ω * u0;\n        }\n        const 𝛿 = α / Math.sqrt(1 + α * α);\n        const u1 = 𝛿 * u0 + Math.sqrt(1 - 𝛿 * 𝛿) * v;\n        const z = u0 >= 0 ? u1 : -u1;\n        let num = ξ + ω * z;\n        if (num < 0) num = randn_bm(min, max, skew);\n        return num;\n    }\n    // console.log(randomSkewNormal);\n    // let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );\n\n    // num = num / 10.0 + 0.5; // Translate to 0 -> 1\n    // if (num > 1 || num < 0) num = randn_bm(min, max, skew); // resample between 0 and 1 if out of range\n    // num = Math.pow(num, skew); // Skew\n    // num *= max - min; // Stretch to fill range\n    // num += min; // offset to min\n    // //return num;\n    return randomSkewNormal(test,ξ,ω,3);\n}\n// Create n samples between min and max\nfor (let i=0; i<n; i+=step) {\n    let rand_num = randn_bm(min, max, skew);\n    temparray.push(rand_num);\n}\n\nreturn temparray;\n}\n\nfunction monteCarlo (dates, randomNumsLeadTime, randomNumsWorkAdded) {\n    let workLeft = dates[dates.length - 1].Backlog - dates[dates.length - 1].Work_Done;\n    let adjustedWorkLeft = workLeft / workInParrallel(mostRecentElevenTicketsArray);\n    let sum = 0;\n    while (sum<adjustedWorkLeft) {\n        sum += randomNumsLeadTime[Math.floor(Math.random() * randomNumsLeadTime.length)];\n    }\n    return sum + sum * randomNumsWorkAdded[Math.floor(Math.random() * randomNumsWorkAdded.length)];\n}\n\nfunction runMonteCarlo (n, dates, randomNumsLeadTime, randomNumsWorkAdded) {\n    let runArray = [];\n    let workAdded = leadTimeAnalysis(computeMeanSdAndItervalRangeMinMax(forplot.map(o => o.Work_Added)));\n    for (let i=0; i<n; i++) {\n        runArray.push(monteCarlo(dates, randomNumsLeadTime, randomNumsWorkAdded));\n    }\n    console.log(computeMeanSdAndItervalRangeMinMax(runArray));\n    console.log(workInParrallel(mostRecentElevenTicketsArray));\n    return runArray;\n}\n\n\n\n\n\n\nfunction Chart(props) {\n    console.log(formatData(props.data));\n    leadTimeAnalysis(computeMeanSdAndItervalRangeMinMax(lastElevenLeadTime(formatData(props.data), today)));\n    console.log(forplot.map(o => o.Work_Added));\n    return (\n        <div className=\"parent\">\n        <div>\n        <Plot\n        data={[\n            //backlog\n          {\n            x: forplot.map(o => o.Day),\n            y: forplot.map(o => o.Backlog),\n            type: 'scatter',\n            mode: 'lines+markers',\n            marker: {color: 'red'},\n          },\n          //work done\n          {\n            x: forplot.map(o => o.Day),\n            y: forplot.map(o => o.Work_Done),\n            type: 'scatter',\n            mode: 'lines+markers',\n            marker: {color: 'green'},\n          }\n        ]}\n        layout={ {width: 500, height: 500, title: 'A Fancy Plot'} }\n      />\n      </div>\n      <div>\n      <Plot\n        data={[\n            //backlog\n            {\n                x: mostRecentElevenTicketsArray.map(o => o['Lead Time']),\n                type: 'histogram',\n                histnorm: 'probability',\n                marker: {\n                    color: 'rgb(255,255,100)',\n                 },\n              },\n        ]}\n        layout={ {width: 500, height: 500, title: 'A Fancy Plot'} }\n      />\n      </div>\n      <div>\n      <Plot\n        data={[\n            //backlog\n            {\n                x: leadTimeAnalysis(computeMeanSdAndItervalRangeMinMax(lastElevenLeadTime(formatData(props.data), today))),\n                type: 'histogram',\n                histnorm: 'probability',\n                marker: {\n                    color: 'rgb(255,255,100)',\n                 },\n              },\n        ]}\n        layout={ {width: 500, height: 500, title: 'A Fancy Plot'} }\n      />\n      </div>\n      <div>\n      <Plot\n        data={[\n            //monteCarlo\n            {\n                x: runMonteCarlo(1000, forplot, leadTimeAnalysis(computeMeanSdAndItervalRangeMinMax(lastElevenLeadTime(formatData(props.data), today))), leadTimeAnalysis(computeMeanSdAndItervalRangeMinMax(forplot.map(o => o.Work_Added)))),\n                type: 'histogram',\n                histnorm: 'probability',\n                marker: {\n                    color: 'rgb(255,100,100)',\n                 },\n              },\n        ]}\n        layout={ {width: 500, height: 500, title: 'Monte Carlo'} }\n      />\n      </div>\n      <div>\n      <Plot\n        data={[\n            //backlog\n            {\n                x: forplot.map(o => o.Work_Added),\n                type: 'histogram',\n                histnorm: 'probability',\n                marker: {\n                    color: 'rgb(255,255,100)',\n                 },\n              },\n        ]}\n        layout={ {width: 500, height: 500, title: 'A Fancy Plot'} }\n      />\n      </div>\n      <div>\n      <Plot\n        data={[\n            //backlog\n            {\n                x: leadTimeAnalysis(computeMeanSdAndItervalRangeMinMax(forplot.map(o => o.Work_Added))),\n                type: 'histogram',\n                histnorm: 'probability',\n                marker: {\n                    color: 'rgb(255,255,100)',\n                 },\n              },\n        ]}\n        layout={ {width: 500, height: 500, title: 'A Fancy Plot'} }\n      />\n      </div>\n      </div>\n      );\n}\nexport default Chart;",{"ruleId":"13","severity":1,"message":"14","line":9,"column":5,"nodeType":"15","messageId":"16","endLine":9,"endColumn":15},{"ruleId":"17","severity":1,"message":"18","line":42,"column":28,"nodeType":"19","messageId":"20","endLine":42,"endColumn":30},{"ruleId":"17","severity":1,"message":"18","line":43,"column":28,"nodeType":"19","messageId":"20","endLine":43,"endColumn":30},{"ruleId":"17","severity":1,"message":"18","line":72,"column":103,"nodeType":"19","messageId":"20","endLine":72,"endColumn":105},{"ruleId":"13","severity":1,"message":"21","line":284,"column":11,"nodeType":"15","messageId":"16","endLine":284,"endColumn":12},{"ruleId":"13","severity":1,"message":"22","line":329,"column":9,"nodeType":"15","messageId":"16","endLine":329,"endColumn":18},"no-unused-vars","'randomData' is assigned a value but never used.","Identifier","unusedVar","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'α' is assigned a value but never used.","'workAdded' is assigned a value but never used."]